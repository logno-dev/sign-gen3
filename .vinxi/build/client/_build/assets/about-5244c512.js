import{z as kt,q as Ee,h as Tt,t as Ut,T as Ot}from"./index-24f52858.js";class h extends Error{code;rawCode;constructor(e,s,n,r){s!==void 0&&(e=`${s}: ${e}`),super(e,{cause:r}),this.code=s,this.rawCode=n,this.name="LibsqlError"}}function Pt(t){const e=Lt.exec(t);if(e===null)throw new h("The URL is not in a valid format","URL_INVALID");const s=e.groups,n=s.scheme,r=s.authority!==void 0?$t(s.authority):void 0,i=E(s.path),c=s.query!==void 0?Bt(s.query):void 0,o=s.fragment!==void 0?E(s.fragment):void 0;return{scheme:n,authority:r,path:i,query:c,fragment:o}}const Lt=(()=>{const t="(?<scheme>[A-Za-z][A-Za-z.+-]*)",e="(?<authority>[^/?#]*)",s="(?<path>[^?#]*)",n="(?<query>[^#]*)",r="(?<fragment>.*)";return new RegExp(`^${t}:(//${e})?${s}(\\?${n})?(#${r})?$`,"su")})();function $t(t){const e=vt.exec(t);if(e===null)throw new h("The authority part of the URL is not in a valid format","URL_INVALID");const s=e.groups,n=E(s.host_br??s.host),r=s.port?parseInt(s.port,10):void 0,i=s.username!==void 0?{username:E(s.username),password:s.password!==void 0?E(s.password):void 0}:void 0;return{host:n,port:r,userinfo:i}}const vt=(()=>{const t="(?<username>[^:]*)(:(?<password>.*))?",e="((?<host>[^:\\[\\]]*)|(\\[(?<host_br>[^\\[\\]]*)\\]))",s="(?<port>[0-9]*)";return new RegExp(`^(${t}@)?${e}(:${s})?$`,"su")})();function Bt(t){const e=t.split("&"),s=[];for(const n of e){if(n==="")continue;let r,i;const c=n.indexOf("=");c<0?(r=n,i=""):(r=n.substring(0,c),i=n.substring(c+1)),s.push({key:E(r.replaceAll("+"," ")),value:E(i.replaceAll("+"," "))})}return{pairs:s}}function E(t){try{return decodeURIComponent(t)}catch(e){throw e instanceof URIError?new h(`URL component has invalid percent encoding: ${e}`,"URL_INVALID",void 0,e):e}}function ie(t,e,s){if(e===void 0)throw new h(`URL with scheme ${JSON.stringify(t+":")} requires authority (the "//" part)`,"URL_INVALID");const n=`${t}:`,r=Nt(e.host),i=Mt(e.port),o=`//${Dt(e.userinfo)}${r}${i}`;let a=s.split("/").map(encodeURIComponent).join("/");return a!==""&&!a.startsWith("/")&&(a="/"+a),new URL(`${n}${o}${a}`)}function Nt(t){return t.includes(":")?`[${encodeURI(t)}]`:encodeURI(t)}function Mt(t){return t!==void 0?`:${t}`:""}function Dt(t){if(t===void 0)return"";const e=encodeURIComponent(t.username),s=t.password!==void 0?`:${encodeURIComponent(t.password)}`:"";return`${e}${s}@`}const Be="3.7.5",Vt=Be,Ft=typeof atob=="function",jt=typeof btoa=="function",N=typeof Buffer=="function",ke=typeof TextDecoder=="function"?new TextDecoder:void 0,Te=typeof TextEncoder=="function"?new TextEncoder:void 0,Ht="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",V=Array.prototype.slice.call(Ht),Q=(t=>{let e={};return t.forEach((s,n)=>e[s]=n),e})(V),Wt=/^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/,m=String.fromCharCode.bind(String),Ue=typeof Uint8Array.from=="function"?Uint8Array.from.bind(Uint8Array):t=>new Uint8Array(Array.prototype.slice.call(t,0)),Ne=t=>t.replace(/=/g,"").replace(/[+\/]/g,e=>e=="+"?"-":"_"),Me=t=>t.replace(/[^A-Za-z0-9\+\/]/g,""),De=t=>{let e,s,n,r,i="";const c=t.length%3;for(let o=0;o<t.length;){if((s=t.charCodeAt(o++))>255||(n=t.charCodeAt(o++))>255||(r=t.charCodeAt(o++))>255)throw new TypeError("invalid character found");e=s<<16|n<<8|r,i+=V[e>>18&63]+V[e>>12&63]+V[e>>6&63]+V[e&63]}return c?i.slice(0,c-3)+"===".substring(c):i},me=jt?t=>btoa(t):N?t=>Buffer.from(t,"binary").toString("base64"):De,oe=N?t=>Buffer.from(t).toString("base64"):t=>{let s=[];for(let n=0,r=t.length;n<r;n+=4096)s.push(m.apply(null,t.subarray(n,n+4096)));return me(s.join(""))},Z=(t,e=!1)=>e?Ne(oe(t)):oe(t),zt=t=>{if(t.length<2){var e=t.charCodeAt(0);return e<128?t:e<2048?m(192|e>>>6)+m(128|e&63):m(224|e>>>12&15)+m(128|e>>>6&63)+m(128|e&63)}else{var e=65536+(t.charCodeAt(0)-55296)*1024+(t.charCodeAt(1)-56320);return m(240|e>>>18&7)+m(128|e>>>12&63)+m(128|e>>>6&63)+m(128|e&63)}},Jt=/[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g,Ve=t=>t.replace(Jt,zt),Oe=N?t=>Buffer.from(t,"utf8").toString("base64"):Te?t=>oe(Te.encode(t)):t=>me(Ve(t)),P=(t,e=!1)=>e?Ne(Oe(t)):Oe(t),Pe=t=>P(t,!0),Gt=/[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g,Qt=t=>{switch(t.length){case 4:var e=(7&t.charCodeAt(0))<<18|(63&t.charCodeAt(1))<<12|(63&t.charCodeAt(2))<<6|63&t.charCodeAt(3),s=e-65536;return m((s>>>10)+55296)+m((s&1023)+56320);case 3:return m((15&t.charCodeAt(0))<<12|(63&t.charCodeAt(1))<<6|63&t.charCodeAt(2));default:return m((31&t.charCodeAt(0))<<6|63&t.charCodeAt(1))}},Fe=t=>t.replace(Gt,Qt),je=t=>{if(t=t.replace(/\s+/g,""),!Wt.test(t))throw new TypeError("malformed base64.");t+="==".slice(2-(t.length&3));let e,s="",n,r;for(let i=0;i<t.length;)e=Q[t.charAt(i++)]<<18|Q[t.charAt(i++)]<<12|(n=Q[t.charAt(i++)])<<6|(r=Q[t.charAt(i++)]),s+=n===64?m(e>>16&255):r===64?m(e>>16&255,e>>8&255):m(e>>16&255,e>>8&255,e&255);return s},we=Ft?t=>atob(Me(t)):N?t=>Buffer.from(t,"base64").toString("binary"):je,He=N?t=>Ue(Buffer.from(t,"base64")):t=>Ue(we(t).split("").map(e=>e.charCodeAt(0))),We=t=>He(ze(t)),Zt=N?t=>Buffer.from(t,"base64").toString("utf8"):ke?t=>ke.decode(He(t)):t=>Fe(we(t)),ze=t=>Me(t.replace(/[-_]/g,e=>e=="-"?"+":"/")),ce=t=>Zt(ze(t)),Yt=t=>{if(typeof t!="string")return!1;const e=t.replace(/\s+/g,"").replace(/={0,2}$/,"");return!/[^\s0-9a-zA-Z\+/]/.test(e)||!/[^\s0-9a-zA-Z\-_]/.test(e)},Je=t=>({value:t,enumerable:!1,writable:!0,configurable:!0}),Ge=function(){const t=(e,s)=>Object.defineProperty(String.prototype,e,Je(s));t("fromBase64",function(){return ce(this)}),t("toBase64",function(e){return P(this,e)}),t("toBase64URI",function(){return P(this,!0)}),t("toBase64URL",function(){return P(this,!0)}),t("toUint8Array",function(){return We(this)})},Qe=function(){const t=(e,s)=>Object.defineProperty(Uint8Array.prototype,e,Je(s));t("toBase64",function(e){return Z(this,e)}),t("toBase64URI",function(){return Z(this,!0)}),t("toBase64URL",function(){return Z(this,!0)})},Kt=()=>{Ge(),Qe()},be={version:Be,VERSION:Vt,atob:we,atobPolyfill:je,btoa:me,btoaPolyfill:De,fromBase64:ce,toBase64:P,encode:P,encodeURI:Pe,encodeURL:Pe,utob:Ve,btou:Fe,decode:ce,isValid:Yt,fromUint8Array:Z,toUint8Array:We,extendString:Ge,extendUint8Array:Qe,extendBuiltins:Kt},W="https://github.com/libsql/libsql-client-ts#supported-urls";function ae(t){if(t==="write")return"BEGIN IMMEDIATE";if(t==="read")return"BEGIN TRANSACTION READONLY";if(t==="deferred")return"BEGIN DEFERRED";throw RangeError('Unknown transaction mode, supported values are "write", "read" and "deferred"')}class Xt{columns;columnTypes;rows;rowsAffected;lastInsertRowid;constructor(e,s,n,r,i){this.columns=e,this.columnTypes=s,this.rows=n,this.rowsAffected=r,this.lastInsertRowid=i}toJSON(){return{columns:this.columns,columnTypes:this.columnTypes,rows:this.rows.map(es),rowsAffected:this.rowsAffected,lastInsertRowid:this.lastInsertRowid!==void 0?""+this.lastInsertRowid:null}}}function es(t){return Array.prototype.map.call(t,ts)}function ts(t){return typeof t=="bigint"?""+t:t instanceof ArrayBuffer?be.fromUint8Array(new Uint8Array(t)):t}function ss(t,e){if(typeof t!="object")throw new TypeError(`Expected client configuration as object, got ${typeof t}`);let s=t.tls,n=t.authToken,r=t.syncUrl;const i=""+(t.intMode??"number");if(i!=="number"&&i!=="bigint"&&i!=="string")throw new TypeError(`Invalid value for intMode, expected "number", "bigint" or "string",             got ${JSON.stringify(i)}`);if(t.url===":memory:")return{path:":memory:",scheme:"file",syncUrl:r,intMode:i,fetch:t.fetch,tls:!1,authToken:void 0,authority:void 0};const c=Pt(t.url);for(const{key:l,value:y}of c.query?.pairs??[])if(l==="authToken")n=y||void 0;else if(l==="tls")if(y==="0")s=!1;else if(y==="1")s=!0;else throw new h(`Unknown value for the "tls" query argument: ${JSON.stringify(y)}. Supported values are "0" and "1"`,"URL_INVALID");else throw new h(`Unknown URL query parameter ${JSON.stringify(l)}`,"URL_PARAM_NOT_SUPPORTED");const o=c.scheme.toLowerCase();let a;if(o==="libsql")if(s===!1){if(c.authority?.port===void 0)throw new h('A "libsql:" URL with ?tls=0 must specify an explicit port',"URL_INVALID");a=e?"http":"ws"}else a=e?"https":"wss";else if(o==="http"||o==="ws")a=o,s??=!1;else if(o==="https"||o==="wss"||o==="file")a=o;else throw new h(`The client supports only "libsql:", "wss:", "ws:", "https:", "http:" and "file:" URLs, got ${JSON.stringify(c.scheme+":")}. For more information, please read ${W}`,"URL_SCHEME_NOT_SUPPORTED");if(c.fragment!==void 0)throw new h(`URL fragments are not supported: ${JSON.stringify("#"+c.fragment)}`,"URL_INVALID");return{scheme:a,tls:s??!0,authority:c.authority,path:c.path,authToken:n,syncUrl:r,intMode:i,fetch:t.fetch}}let U;typeof WebSocket<"u"?U=WebSocket:typeof global<"u"?U=global.WebSocket:typeof window<"u"?U=window.WebSocket:typeof self<"u"&&(U=self.WebSocket);class Ze{constructor(){this.intMode="number"}intMode}class d extends Error{constructor(e){super(e),this.name="ClientError"}}class u extends d{constructor(e){super(e),this.name="ProtoError"}}class Ye extends d{code;proto;constructor(e,s){super(e),this.name="ResponseError",this.code=s.code,this.proto=s,this.stack=void 0}}class _ extends d{constructor(e,s){s!==void 0?(super(`${e}: ${s}`),this.cause=s):super(e),this.name="ClosedError"}}class Ke extends d{constructor(e){super(e),this.name="WebSocketUnsupportedError"}}class ue extends d{constructor(e){super(e),this.name="WebSocketError"}}class Xe extends d{status;constructor(e,s){super(e),this.status=s,this.name="HttpServerError"}}class L extends d{constructor(e){super(e),this.name="ProtocolVersionError"}}class C extends d{constructor(e){super(e),this.name="InternalError"}}class M extends d{constructor(e){super(e),this.name="MisuseError"}}function q(t){if(typeof t=="string")return t;throw D(t,"string")}function g(t){if(t!=null){if(typeof t=="string")return t;throw D(t,"string or null")}}function k(t){if(typeof t=="number")return t;throw D(t,"number")}function z(t){if(typeof t=="boolean")return t;throw D(t,"boolean")}function Y(t){if(Array.isArray(t))return t;throw D(t,"array")}function w(t){if(t!==null&&typeof t=="object"&&!Array.isArray(t))return t;throw D(t,"object")}function I(t,e){return Y(t).map(s=>e(w(s)))}function D(t,e){if(t===void 0)return new u(`Expected ${e}, but the property was missing`);let s=typeof t;return t===null?s="null":Array.isArray(t)&&(s="array"),new u(`Expected ${e}, received ${s}`)}function _e(t,e){return e(w(t))}class ns{#e;#t;constructor(e){this.#e=e,this.#t=!1}begin(){this.#e.push("{"),this.#t=!0}end(){this.#e.push("}"),this.#t=!1}#s(e){this.#t?(this.#e.push('"'),this.#t=!1):this.#e.push(',"'),this.#e.push(e),this.#e.push('":')}string(e,s){this.#s(e),this.#e.push(JSON.stringify(s))}stringRaw(e,s){this.#s(e),this.#e.push('"'),this.#e.push(s),this.#e.push('"')}number(e,s){this.#s(e),this.#e.push(""+s)}boolean(e,s){this.#s(e),this.#e.push(s?"true":"false")}object(e,s,n){this.#s(e),this.begin(),n(this,s),this.end()}arrayObjects(e,s,n){this.#s(e),this.#e.push("[");for(let r=0;r<s.length;++r)r!==0&&this.#e.push(","),this.begin(),n(this,s[r]),this.end();this.#e.push("]")}}function et(t,e){const s=[],n=new ns(s);return n.begin(),e(n,t),n.end(),s.join("")}const j=0,le=1,he=2,rs=5;class is{#e;#t;#s;constructor(e){this.#e=e,this.#t=new DataView(e.buffer,e.byteOffset,e.byteLength),this.#s=0}varint(){let e=0;for(let s=0;;s+=7){const n=this.#e[this.#s++];if(e|=(n&127)<<s,!(n&128))break}return e}varintBig(){let e=0n;for(let s=0n;;s+=7n){const n=this.#e[this.#s++];if(e|=BigInt(n&127)<<s,!(n&128))break}return e}bytes(e){const s=new Uint8Array(this.#e.buffer,this.#e.byteOffset+this.#s,e);return this.#s+=e,s}double(){const e=this.#t.getFloat64(this.#s,!0);return this.#s+=8,e}skipVarint(){for(;this.#e[this.#s++]&128;);}skip(e){this.#s+=e}eof(){return this.#s>=this.#e.byteLength}}class os{#e;#t;constructor(e){this.#e=e,this.#t=-1}setup(e){this.#t=e}#s(e){if(this.#t!==e)throw new u(`Expected wire type ${e}, got ${this.#t}`);this.#t=-1}bytes(){this.#s(he);const e=this.#e.varint();return this.#e.bytes(e)}string(){return new TextDecoder().decode(this.bytes())}message(e){return se(this.bytes(),e)}int32(){return this.#s(j),this.#e.varint()}uint32(){return this.int32()}bool(){return this.int32()!==0}uint64(){return this.#s(j),this.#e.varintBig()}sint64(){const e=this.uint64();return e>>1n^-(e&1n)}double(){return this.#s(le),this.#e.double()}maybeSkip(){if(!(this.#t<0)){if(this.#t===j)this.#e.skipVarint();else if(this.#t===le)this.#e.skip(8);else if(this.#t===he){const e=this.#e.varint();this.#e.skip(e)}else if(this.#t===rs)this.#e.skip(4);else throw new u(`Unexpected wire type ${this.#t}`);this.#t=-1}}}function se(t,e){const s=new is(t),n=new os(s);let r=e.default();for(;!s.eof();){const i=s.varint(),c=i>>3,o=i&7;n.setup(o);const a=e[c];if(a!==void 0){const l=a(n,r);l!==void 0&&(r=l)}n.maybeSkip()}return r}class qe{#e;#t;#s;#n;constructor(){this.#e=new ArrayBuffer(256),this.#t=new Uint8Array(this.#e),this.#s=new DataView(this.#e),this.#n=0}#i(e){if(this.#n+e<=this.#e.byteLength)return;let s=this.#e.byteLength;for(;s<this.#n+e;)s*=2;const n=new ArrayBuffer(s),r=new Uint8Array(n),i=new DataView(n);r.set(new Uint8Array(this.#e,0,this.#n)),this.#e=n,this.#t=r,this.#s=i}#r(e){this.#i(5),e=0|e;do{let s=e&127;e>>>=7,s|=e?128:0,this.#t[this.#n++]=s}while(e)}#o(e){this.#i(10),e=e&0xffffffffffffffffn;do{let s=Number(e&0x7fn);e>>=7n,s|=e?128:0,this.#t[this.#n++]=s}while(e)}#c(e,s){this.#r(e<<3|s)}bytes(e,s){this.#c(e,he),this.#r(s.byteLength),this.#i(s.byteLength),this.#t.set(s,this.#n),this.#n+=s.byteLength}string(e,s){this.bytes(e,new TextEncoder().encode(s))}message(e,s,n){const r=new qe;n(r,s),this.bytes(e,r.data())}int32(e,s){this.#c(e,j),this.#r(s)}uint32(e,s){this.int32(e,s)}bool(e,s){this.int32(e,s?1:0)}sint64(e,s){this.#c(e,j),this.#o(s<<1n^s>>63n)}double(e,s){this.#c(e,le),this.#i(8),this.#s.setFloat64(this.#n,s,!0),this.#n+=8}data(){return new Uint8Array(this.#e,0,this.#n)}}function tt(t,e){const s=new qe;return e(s,t),s.data()}class F{#e;#t;constructor(){this.#e=new Set,this.#t=new Set}alloc(){for(const s of this.#t)return this.#t.delete(s),this.#e.add(s),this.#e.has(this.#e.size-1)||this.#t.add(this.#e.size-1),s;const e=this.#e.size;return this.#e.add(e),e}free(e){if(!this.#e.delete(e))throw new C("Freeing an id that is not allocated");this.#t.delete(this.#e.size),e<this.#e.size&&this.#t.add(e)}}function f(t,e){throw new C(e)}function H(t){if(t===null)return null;if(typeof t=="string")return t;if(typeof t=="number"){if(!Number.isFinite(t))throw new RangeError("Only finite numbers (not Infinity or NaN) can be passed as arguments");return t}else if(typeof t=="bigint"){if(t<cs||t>as)throw new RangeError("This bigint value is too large to be represented as a 64-bit integer and passed as argument");return t}else{if(typeof t=="boolean")return t?1n:0n;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(t instanceof Uint8Array)return t;if(t instanceof Date)return+t.valueOf();if(typeof t=="object")return""+t.toString();throw new TypeError("Unsupported type of value")}}const cs=-9223372036854775808n,as=9223372036854775807n;function st(t,e){if(t===null)return null;if(typeof t=="number")return t;if(typeof t=="string")return t;if(typeof t=="bigint")if(e==="number"){const s=Number(t);if(!Number.isSafeInteger(s))throw new RangeError("Received integer which is too large to be safely represented as a JavaScript number");return s}else{if(e==="bigint")return t;if(e==="string")return""+t;throw new M("Invalid value for IntMode")}else{if(t instanceof Uint8Array)return t.slice().buffer;throw t===void 0?new u("Received unrecognized type of Value"):f(t,"Impossible type of Value")}}function G(t){return{affectedRowCount:t.affectedRowCount,lastInsertRowid:t.lastInsertRowid,columnNames:t.cols.map(e=>e.name),columnDecltypes:t.cols.map(e=>e.decltype)}}function nt(t,e){const s=G(t),n=t.rows.map(r=>ot(s.columnNames,r,e));return{...s,rows:n}}function rt(t,e){const s=G(t);let n;return t.rows.length>0&&(n=ot(s.columnNames,t.rows[0],e)),{...s,row:n}}function it(t,e){const s=G(t);let n;return t.rows.length>0&&s.columnNames.length>0&&(n=st(t.rows[0][0],e)),{...s,value:n}}function ot(t,e,s){const n={};Object.defineProperty(n,"length",{value:e.length});for(let r=0;r<e.length;++r){const i=st(e[r],s);Object.defineProperty(n,r,{value:i});const c=t[r];c!==void 0&&!Object.hasOwn(n,c)&&Object.defineProperty(n,c,{value:i,enumerable:!0})}return n}function $(t){return new Ye(t.message,t)}class ge{#e;#t;#s;constructor(e,s){this.#e=e,this.#t=s,this.#s=void 0}_getSqlId(e){if(this.#e!==e)throw new M("Attempted to use SQL text opened with other object");if(this.#s!==void 0)throw new _("SQL text is closed",this.#s);return this.#t}close(){this._setClosed(new d("SQL text was manually closed"))}_setClosed(e){this.#s===void 0&&(this.#s=e,this.#e._closeSql(this.#t))}get closed(){return this.#s!==void 0}}function de(t,e){return e instanceof ge?{sqlId:e._getSqlId(t)}:{sql:""+e}}class K{#e;#t;constructor(){this.#e=[],this.#t=[]}get length(){return this.#e.length+this.#t.length}push(e){this.#e.push(e)}shift(){return this.#t.length===0&&this.#e.length>0&&(this.#t=this.#e.reverse(),this.#e=[]),this.#t.pop()}first(){return this.#t.length!==0?this.#t[this.#t.length-1]:this.#e[0]}}let fe=class{sql;_args;_namedArgs;constructor(e){this.sql=e,this._args=[],this._namedArgs=new Map}bindIndexes(e){this._args.length=0;for(const s of e)this._args.push(H(s));return this}bindIndex(e,s){if(e!==(e|0)||e<=0)throw new RangeError("Index of a positional argument must be positive integer");for(;this._args.length<e;)this._args.push(null);return this._args[e-1]=H(s),this}bindName(e,s){return this._namedArgs.set(e,H(s)),this}unbindAll(){return this._args.length=0,this._namedArgs.clear(),this}};function ct(t,e,s){let n,r=[],i=[];if(e instanceof fe){n=e.sql,r=e._args;for(const[a,l]of e._namedArgs.entries())i.push({name:a,value:l})}else Array.isArray(e)?(n=e[0],Array.isArray(e[1])?r=e[1].map(a=>H(a)):i=Object.entries(e[1]).map(([a,l])=>({name:a,value:H(l)}))):n=e;const{sql:c,sqlId:o}=de(t,n);return{sql:c,sqlId:o,args:r,namedArgs:i,wantRows:s}}let us=class{_stream;#e;_steps;#t;constructor(e,s){this._stream=e,this.#e=s,this._steps=[],this.#t=!1}step(){return new ds(this)}execute(){if(this.#t)throw new M("This batch has already been executed");this.#t=!0;const e={steps:this._steps.map(s=>s.proto)};return this.#e?hs(this._stream,this._steps,e):ls(this._stream,this._steps,e)}};function ls(t,e,s){return t._batch(s).then(n=>{for(let r=0;r<e.length;++r){const i=n.stepResults.get(r),c=n.stepErrors.get(r);e[r].callback(i,c)}})}async function hs(t,e,s){const n=await t._openCursor(s);try{let r=0,i,c=[];for(;;){const o=await n.next();if(o===void 0)break;if(o.type==="step_begin"){if(o.step<r||o.step>=e.length)throw new u("Server produced StepBeginEntry for unexpected step");if(i!==void 0)throw new u("Server produced StepBeginEntry before terminating previous step");for(let a=r;a<o.step;++a)e[a].callback(void 0,void 0);r=o.step+1,i=o,c=[]}else if(o.type==="step_end"){if(i===void 0)throw new u("Server produced StepEndEntry but no step is active");const a={cols:i.cols,rows:c,affectedRowCount:o.affectedRowCount,lastInsertRowid:o.lastInsertRowid};e[i.step].callback(a,void 0),i=void 0,c=[]}else if(o.type==="step_error"){if(i===void 0){if(o.step>=e.length)throw new u("Server produced StepErrorEntry for unexpected step");for(let a=r;a<o.step;++a)e[a].callback(void 0,void 0)}else{if(o.step!==i.step)throw new u("Server produced StepErrorEntry for unexpected step");i=void 0,c=[]}e[o.step].callback(void 0,o.error),r=o.step+1}else if(o.type==="row"){if(i===void 0)throw new u("Server produced RowEntry but no step is active");c.push(o.row)}else throw o.type==="error"?$(o.error):o.type==="none"?new u("Server produced unrecognized CursorEntry"):f(o,"Impossible CursorEntry")}if(i!==void 0)throw new u("Server closed Cursor before terminating active step");for(let o=r;o<e.length;++o)e[o].callback(void 0,void 0)}finally{n.close()}}let ds=class{_batch;#e;_index;constructor(e){this._batch=e,this.#e=[],this._index=void 0}condition(e){return this.#e.push(e._proto),this}query(e){return this.#t(e,!0,nt)}queryRow(e){return this.#t(e,!0,rt)}queryValue(e){return this.#t(e,!0,it)}run(e){return this.#t(e,!1,G)}#t(e,s,n){if(this._index!==void 0)throw new M("This BatchStep has already been added to the batch");const r=ct(this._batch._stream._sqlOwner(),e,s);let i;this.#e.length===0?i=void 0:this.#e.length===1?i=this.#e[0]:i={type:"and",conds:this.#e.slice()};const c={stmt:r,condition:i};return new Promise((o,a)=>{const l=(y,R)=>{y!==void 0&&R!==void 0?a(new u("Server returned both result and error")):R!==void 0?a($(R)):o(y!==void 0?n(y,this._batch._stream.intMode):void 0)};this._index=this._batch._steps.length,this._batch._steps.push({proto:c,callback:l})})}},b=class A{_batch;_proto;constructor(e,s){this._batch=e,this._proto=s}static ok(e){return new A(e._batch,{type:"ok",step:Le(e)})}static error(e){return new A(e._batch,{type:"error",step:Le(e)})}static not(e){return new A(e._batch,{type:"not",cond:e._proto})}static and(e,s){for(const n of s)$e(e,n);return new A(e,{type:"and",conds:s.map(n=>n._proto)})}static or(e,s){for(const n of s)$e(e,n);return new A(e,{type:"or",conds:s.map(n=>n._proto)})}static isAutocommit(e){return e._stream.client()._ensureVersion(3,"BatchCond.isAutocommit()"),new A(e,{type:"is_autocommit"})}};function Le(t){if(t._index===void 0)throw new M("Cannot add a condition referencing a step that has not been added to the batch");return t._index}function $e(t,e){if(e._batch!==t)throw new M("Cannot mix BatchCond objects for different Batch objects")}function fs(t){return{paramNames:t.params.map(e=>e.name),columns:t.cols,isExplain:t.isExplain,isReadonly:t.isReadonly}}class at{constructor(e){this.intMode=e}query(e){return this.#e(e,!0,nt)}queryRow(e){return this.#e(e,!0,rt)}queryValue(e){return this.#e(e,!0,it)}run(e){return this.#e(e,!1,G)}#e(e,s,n){const r=ct(this._sqlOwner(),e,s);return this._execute(r).then(i=>n(i,this.intMode))}batch(e=!1){return new us(this,e)}describe(e){const s=de(this._sqlOwner(),e);return this._describe(s).then(fs)}sequence(e){const s=de(this._sqlOwner(),e);return this._sequence(s)}intMode}class ut{}const ps=1e3,ys=10;class ms extends ut{#e;#t;#s;#n;#i;#r;#o;constructor(e,s,n){super(),this.#e=e,this.#t=s,this.#s=n,this.#n=new K,this.#i=new K,this.#r=void 0,this.#o=!1}async next(){for(;;){if(this.#r!==void 0)throw new _("Cursor is closed",this.#r);for(;!this.#o&&this.#i.length<ys;)this.#i.push(this.#c());const e=this.#n.shift();if(this.#o||e!==void 0)return e;await this.#i.shift().then(s=>{if(s!==void 0){for(const n of s.entries)this.#n.push(n);this.#o||=s.done}})}}#c(){return this.#t._sendCursorRequest(this,{type:"fetch_cursor",cursorId:this.#s,maxCount:ps}).then(e=>e,e=>{this._setClosed(e)})}_setClosed(e){this.#r===void 0&&(this.#r=e,this.#t._sendCursorRequest(this,{type:"close_cursor",cursorId:this.#s}).catch(()=>{}),this.#t._cursorClosed(this))}close(){this._setClosed(new d("Cursor was manually closed"))}get closed(){return this.#r!==void 0}}class Re extends at{#e;#t;#s;#n;#i;#r;static open(e){const s=e._streamIdAlloc.alloc(),n=new Re(e,s),r=()=>{},i=o=>n.#u(o),c={type:"open_stream",streamId:s};return e._sendRequest(c,{responseCallback:r,errorCallback:i}),n}constructor(e,s){super(e.intMode),this.#e=e,this.#t=s,this.#s=new K,this.#n=void 0,this.#i=!1,this.#r=void 0}client(){return this.#e}_sqlOwner(){return this.#e}_execute(e){return this.#o({type:"execute",streamId:this.#t,stmt:e}).then(s=>s.result)}_batch(e){return this.#o({type:"batch",streamId:this.#t,batch:e}).then(s=>s.result)}_describe(e){return this.#e._ensureVersion(2,"describe()"),this.#o({type:"describe",streamId:this.#t,sql:e.sql,sqlId:e.sqlId}).then(s=>s.result)}_sequence(e){return this.#e._ensureVersion(2,"sequence()"),this.#o({type:"sequence",streamId:this.#t,sql:e.sql,sqlId:e.sqlId}).then(s=>{})}getAutocommit(){return this.#e._ensureVersion(3,"getAutocommit()"),this.#o({type:"get_autocommit",streamId:this.#t}).then(e=>e.isAutocommit)}#o(e){return new Promise((s,n)=>{this.#c({type:"request",request:e,responseCallback:s,errorCallback:n})})}_openCursor(e){return this.#e._ensureVersion(3,"cursor"),new Promise((s,n)=>{this.#c({type:"cursor",batch:e,cursorCallback:s,errorCallback:n})})}_sendCursorRequest(e,s){if(e!==this.#n)throw new C("Cursor not associated with the stream attempted to execute a request");return new Promise((n,r)=>{this.#r!==void 0?r(new _("Stream is closed",this.#r)):this.#e._sendRequest(s,{responseCallback:n,errorCallback:r})})}_cursorClosed(e){if(e!==this.#n)throw new C("Cursor was closed, but it was not associated with the stream");this.#n=void 0,this.#a()}#c(e){this.#r!==void 0?e.errorCallback(new _("Stream is closed",this.#r)):this.#i?e.errorCallback(new _("Stream is closing",void 0)):(this.#s.push(e),this.#a())}#a(){for(;;){const e=this.#s.first();if(e===void 0&&this.#n===void 0&&this.#i){this.#u(new d("Stream was gracefully closed"));break}else if(e?.type==="request"&&this.#n===void 0){const{request:s,responseCallback:n,errorCallback:r}=e;this.#s.shift(),this.#e._sendRequest(s,{responseCallback:n,errorCallback:r})}else if(e?.type==="cursor"&&this.#n===void 0){const{batch:s,cursorCallback:n}=e;this.#s.shift();const r=this.#e._cursorIdAlloc.alloc(),i=new ms(this.#e,this,r),c={type:"open_cursor",streamId:this.#t,cursorId:r,batch:s},o=()=>{},a=l=>i._setClosed(l);this.#e._sendRequest(c,{responseCallback:o,errorCallback:a}),this.#n=i,n(i)}else break}}#u(e){if(this.#r!==void 0)return;for(this.#r=e,this.#n!==void 0&&this.#n._setClosed(e);;){const i=this.#s.shift();if(i!==void 0)i.errorCallback(e);else break}const s={type:"close_stream",streamId:this.#t},n=()=>this.#e._streamIdAlloc.free(this.#t),r=()=>{};this.#e._sendRequest(s,{responseCallback:n,errorCallback:r})}close(){this.#u(new d("Stream was manually closed"))}closeGracefully(){this.#i=!0,this.#a()}get closed(){return this.#r!==void 0||this.#i}}function Se(t,e){e.sql!==void 0&&t.string("sql",e.sql),e.sqlId!==void 0&&t.number("sql_id",e.sqlId),t.arrayObjects("args",e.args,lt),t.arrayObjects("named_args",e.namedArgs,ws),t.boolean("want_rows",e.wantRows)}function ws(t,e){t.string("name",e.name),t.object("value",e.value,lt)}function X(t,e){t.arrayObjects("steps",e.steps,bs)}function bs(t,e){e.condition!==void 0&&t.object("condition",e.condition,pe),t.object("stmt",e.stmt,Se)}function pe(t,e){if(t.stringRaw("type",e.type),e.type==="ok"||e.type==="error")t.number("step",e.step);else if(e.type==="not")t.object("cond",e.cond,pe);else if(e.type==="and"||e.type==="or")t.arrayObjects("conds",e.conds,pe);else if(e.type!=="is_autocommit")throw f(e,"Impossible type of BatchCond")}function lt(t,e){if(e===null)t.stringRaw("type","null");else if(typeof e=="bigint")t.stringRaw("type","integer"),t.stringRaw("value",""+e);else if(typeof e=="number")t.stringRaw("type","float"),t.number("value",e);else if(typeof e=="string")t.stringRaw("type","text"),t.string("value",e);else if(e instanceof Uint8Array)t.stringRaw("type","blob"),t.stringRaw("base64",be.fromUint8Array(e));else if(e!==void 0)throw f(e,"Impossible type of Value")}function _s(t,e){if(t.stringRaw("type",e.type),e.type==="hello")e.jwt!==void 0&&t.string("jwt",e.jwt);else if(e.type==="request")t.number("request_id",e.requestId),t.object("request",e.request,qs);else throw f(e,"Impossible type of ClientMsg")}function qs(t,e){if(t.stringRaw("type",e.type),e.type==="open_stream")t.number("stream_id",e.streamId);else if(e.type==="close_stream")t.number("stream_id",e.streamId);else if(e.type==="execute")t.number("stream_id",e.streamId),t.object("stmt",e.stmt,Se);else if(e.type==="batch")t.number("stream_id",e.streamId),t.object("batch",e.batch,X);else if(e.type==="open_cursor")t.number("stream_id",e.streamId),t.number("cursor_id",e.cursorId),t.object("batch",e.batch,X);else if(e.type==="close_cursor")t.number("cursor_id",e.cursorId);else if(e.type==="fetch_cursor")t.number("cursor_id",e.cursorId),t.number("max_count",e.maxCount);else if(e.type==="sequence")t.number("stream_id",e.streamId),e.sql!==void 0&&t.string("sql",e.sql),e.sqlId!==void 0&&t.number("sql_id",e.sqlId);else if(e.type==="describe")t.number("stream_id",e.streamId),e.sql!==void 0&&t.string("sql",e.sql),e.sqlId!==void 0&&t.number("sql_id",e.sqlId);else if(e.type==="store_sql")t.number("sql_id",e.sqlId),t.string("sql",e.sql);else if(e.type==="close_sql")t.number("sql_id",e.sqlId);else if(e.type==="get_autocommit")t.number("stream_id",e.streamId);else throw f(e,"Impossible type of Request")}function Ce(t,e){e.sql!==void 0&&t.string(1,e.sql),e.sqlId!==void 0&&t.int32(2,e.sqlId);for(const s of e.args)t.message(3,s,ht);for(const s of e.namedArgs)t.message(4,s,gs);t.bool(5,e.wantRows)}function gs(t,e){t.string(1,e.name),t.message(2,e.value,ht)}function ne(t,e){for(const s of e.steps)t.message(1,s,Rs)}function Rs(t,e){e.condition!==void 0&&t.message(1,e.condition,Ie),t.message(2,e.stmt,Ce)}function Ie(t,e){if(e.type==="ok")t.uint32(1,e.step);else if(e.type==="error")t.uint32(2,e.step);else if(e.type==="not")t.message(3,e.cond,Ie);else if(e.type==="and")t.message(4,e.conds,ve);else if(e.type==="or")t.message(5,e.conds,ve);else if(e.type==="is_autocommit")t.message(6,void 0,dt);else throw f(e,"Impossible type of BatchCond")}function ve(t,e){for(const s of e)t.message(1,s,Ie)}function ht(t,e){if(e===null)t.message(1,void 0,dt);else if(typeof e=="bigint")t.sint64(2,e);else if(typeof e=="number")t.double(3,e);else if(typeof e=="string")t.string(4,e);else if(e instanceof Uint8Array)t.bytes(5,e);else if(e!==void 0)throw f(e,"Impossible type of Value")}function dt(t,e){}function Ss(t,e){if(e.type==="hello")t.message(1,e,Cs);else if(e.type==="request")t.message(2,e,Is);else throw f(e,"Impossible type of ClientMsg")}function Cs(t,e){e.jwt!==void 0&&t.string(1,e.jwt)}function Is(t,e){t.int32(1,e.requestId);const s=e.request;if(s.type==="open_stream")t.message(2,s,xs);else if(s.type==="close_stream")t.message(3,s,As);else if(s.type==="execute")t.message(4,s,Es);else if(s.type==="batch")t.message(5,s,ks);else if(s.type==="open_cursor")t.message(6,s,Ts);else if(s.type==="close_cursor")t.message(7,s,Us);else if(s.type==="fetch_cursor")t.message(8,s,Os);else if(s.type==="sequence")t.message(9,s,Ps);else if(s.type==="describe")t.message(10,s,Ls);else if(s.type==="store_sql")t.message(11,s,$s);else if(s.type==="close_sql")t.message(12,s,vs);else if(s.type==="get_autocommit")t.message(13,s,Bs);else throw f(s,"Impossible type of Request")}function xs(t,e){t.int32(1,e.streamId)}function As(t,e){t.int32(1,e.streamId)}function Es(t,e){t.int32(1,e.streamId),t.message(2,e.stmt,Ce)}function ks(t,e){t.int32(1,e.streamId),t.message(2,e.batch,ne)}function Ts(t,e){t.int32(1,e.streamId),t.int32(2,e.cursorId),t.message(3,e.batch,ne)}function Us(t,e){t.int32(1,e.cursorId)}function Os(t,e){t.int32(1,e.cursorId),t.uint32(2,e.maxCount)}function Ps(t,e){t.int32(1,e.streamId),e.sql!==void 0&&t.string(2,e.sql),e.sqlId!==void 0&&t.int32(3,e.sqlId)}function Ls(t,e){t.int32(1,e.streamId),e.sql!==void 0&&t.string(2,e.sql),e.sqlId!==void 0&&t.int32(3,e.sqlId)}function $s(t,e){t.int32(1,e.sqlId),t.string(2,e.sql)}function vs(t,e){t.int32(1,e.sqlId)}function Bs(t,e){t.int32(1,e.streamId)}function v(t){const e=q(t.message),s=g(t.code);return{message:e,code:s}}function xe(t){const e=I(t.cols,ft),s=Y(t.rows).map(c=>I(c,wt)),n=k(t.affected_row_count),r=g(t.last_insert_rowid),i=r!==void 0?BigInt(r):void 0;return{cols:e,rows:s,affectedRowCount:n,lastInsertRowid:i}}function ft(t){const e=g(t.name),s=g(t.decltype);return{name:e,decltype:s}}function pt(t){const e=new Map;Y(t.step_results).forEach((n,r)=>{n!==null&&e.set(r,xe(w(n)))});const s=new Map;return Y(t.step_errors).forEach((n,r)=>{n!==null&&s.set(r,v(w(n)))}),{stepResults:e,stepErrors:s}}function yt(t){const e=q(t.type);if(e==="step_begin"){const s=k(t.step),n=I(t.cols,ft);return{type:"step_begin",step:s,cols:n}}else if(e==="step_end"){const s=k(t.affected_row_count),n=g(t.last_insert_rowid),r=n!==void 0?BigInt(n):void 0;return{type:"step_end",affectedRowCount:s,lastInsertRowid:r}}else if(e==="step_error"){const s=k(t.step),n=v(w(t.error));return{type:"step_error",step:s,error:n}}else{if(e==="row")return{type:"row",row:I(t.row,wt)};if(e==="error")return{type:"error",error:v(w(t.error))};throw new u("Unexpected type of CursorEntry")}}function mt(t){const e=I(t.params,Ns),s=I(t.cols,Ms),n=z(t.is_explain),r=z(t.is_readonly);return{params:e,cols:s,isExplain:n,isReadonly:r}}function Ns(t){return{name:g(t.name)}}function Ms(t){const e=q(t.name),s=g(t.decltype);return{name:e,decltype:s}}function wt(t){const e=q(t.type);if(e==="null")return null;if(e==="integer"){const s=q(t.value);return BigInt(s)}else{if(e==="float")return k(t.value);if(e==="text")return q(t.value);if(e==="blob")return be.toUint8Array(q(t.base64));throw new u("Unexpected type of Value")}}function Ds(t){const e=q(t.type);if(e==="hello_ok")return{type:"hello_ok"};if(e==="hello_error")return{type:"hello_error",error:v(w(t.error))};if(e==="response_ok"){const s=k(t.request_id),n=Vs(w(t.response));return{type:"response_ok",requestId:s,response:n}}else if(e==="response_error"){const s=k(t.request_id),n=v(w(t.error));return{type:"response_error",requestId:s,error:n}}else throw new u("Unexpected type of ServerMsg")}function Vs(t){const e=q(t.type);if(e==="open_stream")return{type:"open_stream"};if(e==="close_stream")return{type:"close_stream"};if(e==="execute")return{type:"execute",result:xe(w(t.result))};if(e==="batch")return{type:"batch",result:pt(w(t.result))};if(e==="open_cursor")return{type:"open_cursor"};if(e==="close_cursor")return{type:"close_cursor"};if(e==="fetch_cursor"){const s=I(t.entries,yt),n=z(t.done);return{type:"fetch_cursor",entries:s,done:n}}else{if(e==="sequence")return{type:"sequence"};if(e==="describe")return{type:"describe",result:mt(w(t.result))};if(e==="store_sql")return{type:"store_sql"};if(e==="close_sql")return{type:"close_sql"};if(e==="get_autocommit")return{type:"get_autocommit",isAutocommit:z(t.is_autocommit)};throw new u("Unexpected type of Response")}}const S={default(){return{message:"",code:void 0}},1(t,e){e.message=t.string()},2(t,e){e.code=t.string()}},B={default(){return{cols:[],rows:[],affectedRowCount:0,lastInsertRowid:void 0}},1(t,e){e.cols.push(t.message(bt))},2(t,e){e.rows.push(t.message(_t))},3(t,e){e.affectedRowCount=Number(t.uint64())},4(t,e){e.lastInsertRowid=t.sint64()}},bt={default(){return{name:void 0,decltype:void 0}},1(t,e){e.name=t.string()},2(t,e){e.decltype=t.string()}},_t={default(){return[]},1(t,e){e.push(t.message(Qs))}},ee={default(){return{stepResults:new Map,stepErrors:new Map}},1(t,e){const[s,n]=t.message(Fs);e.stepResults.set(s,n)},2(t,e){const[s,n]=t.message(js);e.stepErrors.set(s,n)}},Fs={default(){return[0,B.default()]},1(t,e){e[0]=t.uint32()},2(t,e){e[1]=t.message(B)}},js={default(){return[0,S.default()]},1(t,e){e[0]=t.uint32()},2(t,e){e[1]=t.message(S)}},qt={default(){return{type:"none"}},1(t){return t.message(Hs)},2(t){return t.message(Ws)},3(t){return t.message(zs)},4(t){return{type:"row",row:t.message(_t)}},5(t){return{type:"error",error:t.message(S)}}},Hs={default(){return{type:"step_begin",step:0,cols:[]}},1(t,e){e.step=t.uint32()},2(t,e){e.cols.push(t.message(bt))}},Ws={default(){return{type:"step_end",affectedRowCount:0,lastInsertRowid:void 0}},1(t,e){e.affectedRowCount=t.uint32()},2(t,e){e.lastInsertRowid=t.uint64()}},zs={default(){return{type:"step_error",step:0,error:S.default()}},1(t,e){e.step=t.uint32()},2(t,e){e.error=t.message(S)}},te={default(){return{params:[],cols:[],isExplain:!1,isReadonly:!1}},1(t,e){e.params.push(t.message(Js))},2(t,e){e.cols.push(t.message(Gs))},3(t,e){e.isExplain=t.bool()},4(t,e){e.isReadonly=t.bool()}},Js={default(){return{name:void 0}},1(t,e){e.name=t.string()}},Gs={default(){return{name:"",decltype:void 0}},1(t,e){e.name=t.string()},2(t,e){e.decltype=t.string()}},Qs={default(){},1(t){return null},2(t){return t.sint64()},3(t){return t.double()},4(t){return t.string()},5(t){return t.bytes()}},Zs={default(){return{type:"none"}},1(t){return{type:"hello_ok"}},2(t){return t.message(Ys)},3(t){return t.message(Xs)},4(t){return t.message(Ks)}},Ys={default(){return{type:"hello_error",error:S.default()}},1(t,e){e.error=t.message(S)}},Ks={default(){return{type:"response_error",requestId:0,error:S.default()}},1(t,e){e.requestId=t.int32()},2(t,e){e.error=t.message(S)}},Xs={default(){return{type:"response_ok",requestId:0,response:{type:"none"}}},1(t,e){e.requestId=t.int32()},2(t,e){e.response={type:"open_stream"}},3(t,e){e.response={type:"close_stream"}},4(t,e){e.response=t.message(en)},5(t,e){e.response=t.message(tn)},6(t,e){e.response={type:"open_cursor"}},7(t,e){e.response={type:"close_cursor"}},8(t,e){e.response=t.message(sn)},9(t,e){e.response={type:"sequence"}},10(t,e){e.response=t.message(nn)},11(t,e){e.response={type:"store_sql"}},12(t,e){e.response={type:"close_sql"}},13(t,e){e.response=t.message(rn)}},en={default(){return{type:"execute",result:B.default()}},1(t,e){e.result=t.message(B)}},tn={default(){return{type:"batch",result:ee.default()}},1(t,e){e.result=t.message(ee)}},sn={default(){return{type:"fetch_cursor",entries:[],done:!1}},1(t,e){e.entries.push(t.message(qt))},2(t,e){e.done=t.bool()}},nn={default(){return{type:"describe",result:te.default()}},1(t,e){e.result=t.message(te)}},rn={default(){return{type:"get_autocommit",isAutocommit:!1}},1(t,e){e.isAutocommit=t.bool()}},on=new Map([["hrana2",{version:2,encoding:"json"}],["hrana1",{version:1,encoding:"json"}]]),gt=new Map([["hrana3-protobuf",{version:3,encoding:"protobuf"}],["hrana3",{version:3,encoding:"json"}],["hrana2",{version:2,encoding:"json"}],["hrana1",{version:1,encoding:"json"}]]);let cn=class extends Ze{#e;#t;#s;#n;#i;#r;#o;#c;#a;_streamIdAlloc;_cursorIdAlloc;#u;constructor(e,s){super(),this.#e=e,this.#t=[],this.#s=!1,this.#n=void 0,this.#i=!1,this.#r=void 0,this.#o=!1,this.#c=new Map,this.#a=new F,this._streamIdAlloc=new F,this._cursorIdAlloc=new F,this.#u=new F,this.#e.binaryType="arraybuffer",this.#e.addEventListener("open",()=>this.#p()),this.#e.addEventListener("close",n=>this.#f(n)),this.#e.addEventListener("error",n=>this.#y(n)),this.#e.addEventListener("message",n=>this.#w(n)),this.#h({type:"hello",jwt:s})}#h(e){if(this.#n!==void 0)throw new C("Trying to send a message on a closed client");if(this.#s)this.#d(e);else{const s=()=>this.#d(e),n=()=>{};this.#t.push({openCallback:s,errorCallback:n})}}#p(){const e=this.#e.protocol;if(e===void 0){this.#l(new d("The `WebSocket.protocol` property is undefined. This most likely means that the WebSocket implementation provided by the environment is broken. If you are using Miniflare 2, please update to Miniflare 3, which fixes this problem."));return}else if(e==="")this.#r={version:1,encoding:"json"};else if(this.#r=gt.get(e),this.#r===void 0){this.#l(new u(`Unrecognized WebSocket subprotocol: ${JSON.stringify(e)}`));return}for(const s of this.#t)s.openCallback();this.#t.length=0,this.#s=!0}#d(e){const s=this.#r.encoding;if(s==="json"){const n=et(e,_s);this.#e.send(n)}else if(s==="protobuf"){const n=tt(e,Ss);this.#e.send(n)}else throw f(s,"Impossible encoding")}getVersion(){return new Promise((e,s)=>{if(this.#o=!0,this.#n!==void 0)s(this.#n);else if(this.#s)e(this.#r.version);else{const n=()=>e(this.#r.version);this.#t.push({openCallback:n,errorCallback:s})}})}_ensureVersion(e,s){if(this.#r===void 0||!this.#o)throw new L(`${s} is supported only on protocol version ${e} and higher, but the version supported by the WebSocket server is not yet known. Use Client.getVersion() to wait until the version is available.`);if(this.#r.version<e)throw new L(`${s} is supported on protocol version ${e} and higher, but the WebSocket server only supports version ${this.#r.version}`)}_sendRequest(e,s){if(this.#n!==void 0){s.errorCallback(new _("Client is closed",this.#n));return}const n=this.#a.alloc();this.#c.set(n,{...s,type:e.type}),this.#h({type:"request",requestId:n,request:e})}#y(e){const n=e.message??"WebSocket was closed due to an error";this.#l(new ue(n))}#f(e){let s=`WebSocket was closed with code ${e.code}`;e.reason&&(s+=`: ${e.reason}`),this.#l(new ue(s))}#l(e){if(this.#n===void 0){this.#n=e;for(const s of this.#t)s.errorCallback(e);this.#t.length=0;for(const[s,n]of this.#c.entries())n.errorCallback(e),this.#a.free(s);this.#c.clear(),this.#e.close()}}#w(e){if(this.#n===void 0)try{let s;const n=this.#r.encoding;if(n==="json"){if(typeof e.data!="string"){this.#e.close(3003,"Only text messages are accepted with JSON encoding"),this.#l(new u("Received non-text message from server with JSON encoding"));return}s=_e(JSON.parse(e.data),Ds)}else if(n==="protobuf"){if(!(e.data instanceof ArrayBuffer)){this.#e.close(3003,"Only binary messages are accepted with Protobuf encoding"),this.#l(new u("Received non-binary message from server with Protobuf encoding"));return}s=se(new Uint8Array(e.data),Zs)}else throw f(n,"Impossible encoding");this.#m(s)}catch(s){this.#e.close(3007,"Could not handle message"),this.#l(s)}}#m(e){if(e.type==="none")throw new u("Received an unrecognized ServerMsg");if(e.type==="hello_ok"||e.type==="hello_error"){if(this.#i)throw new u("Received a duplicated hello response");if(this.#i=!0,e.type==="hello_error")throw $(e.error);return}else if(!this.#i)throw new u("Received a non-hello message before a hello response");if(e.type==="response_ok"){const s=e.requestId,n=this.#c.get(s);if(this.#c.delete(s),n===void 0)throw new u("Received unexpected OK response");this.#a.free(s);try{if(n.type!==e.response.type)throw console.dir({responseState:n,msg:e}),new u("Received unexpected type of response");n.responseCallback(e.response)}catch(r){throw n.errorCallback(r),r}}else if(e.type==="response_error"){const s=e.requestId,n=this.#c.get(s);if(this.#c.delete(s),n===void 0)throw new u("Received unexpected error response");this.#a.free(s),n.errorCallback($(e.error))}else throw f(e,"Impossible ServerMsg type")}openStream(){return Re.open(this)}storeSql(e){this._ensureVersion(2,"storeSql()");const s=this.#u.alloc(),n=new ge(this,s),r=()=>{},i=o=>n._setClosed(o),c={type:"store_sql",sqlId:s,sql:e};return this._sendRequest(c,{responseCallback:r,errorCallback:i}),n}_closeSql(e){if(this.#n!==void 0)return;const s=()=>this.#u.free(e),n=i=>this.#l(i),r={type:"close_sql",sqlId:e};this._sendRequest(r,{responseCallback:s,errorCallback:n})}close(){this.#l(new d("Client was manually closed"))}get closed(){return this.#n!==void 0}};const an=fetch,Rt=Request,un=Headers;let O;if(typeof queueMicrotask<"u")O=queueMicrotask;else{const t=Promise.resolve();O=e=>{t.then(e)}}class ln{#e;#t;#s;constructor(e){this.#e=new Uint8Array(new ArrayBuffer(e)),this.#t=0,this.#s=0}get length(){return this.#s-this.#t}data(){return this.#e.slice(this.#t,this.#s)}push(e){this.#n(e.byteLength),this.#e.set(e,this.#s),this.#s+=e.byteLength}#n(e){if(this.#s+e<=this.#e.byteLength)return;const s=this.#s-this.#t;if(s+e<=this.#e.byteLength&&2*this.#s>=this.#e.byteLength)this.#e.copyWithin(0,this.#t,this.#s);else{let n=this.#e.byteLength;do n*=2;while(s+e>n);const r=new Uint8Array(new ArrayBuffer(n));r.set(this.#e.slice(this.#t,this.#s),0),this.#e=r}this.#s=s,this.#t=0}shift(e){this.#t+=e}}function hn(t){const e=g(t.baton),s=g(t.base_url),n=I(t.results,dn);return{baton:e,baseUrl:s,results:n}}function dn(t){const e=q(t.type);if(e==="ok")return{type:"ok",response:fn(w(t.response))};if(e==="error")return{type:"error",error:v(w(t.error))};throw new u("Unexpected type of StreamResult")}function fn(t){const e=q(t.type);if(e==="close")return{type:"close"};if(e==="execute")return{type:"execute",result:xe(w(t.result))};if(e==="batch")return{type:"batch",result:pt(w(t.result))};if(e==="sequence")return{type:"sequence"};if(e==="describe")return{type:"describe",result:mt(w(t.result))};if(e==="store_sql")return{type:"store_sql"};if(e==="close_sql")return{type:"close_sql"};if(e==="get_autocommit")return{type:"get_autocommit",isAutocommit:z(t.is_autocommit)};throw new u("Unexpected type of StreamResponse")}function pn(t){const e=g(t.baton),s=g(t.base_url);return{baton:e,baseUrl:s}}const yn={default(){return{baton:void 0,baseUrl:void 0,results:[]}},1(t,e){e.baton=t.string()},2(t,e){e.baseUrl=t.string()},3(t,e){e.results.push(t.message(mn))}},mn={default(){return{type:"none"}},1(t){return{type:"ok",response:t.message(wn)}},2(t){return{type:"error",error:t.message(S)}}},wn={default(){return{type:"none"}},1(t){return{type:"close"}},2(t){return t.message(bn)},3(t){return t.message(_n)},4(t){return{type:"sequence"}},5(t){return t.message(qn)},6(t){return{type:"store_sql"}},7(t){return{type:"close_sql"}},8(t){return t.message(gn)}},bn={default(){return{type:"execute",result:B.default()}},1(t,e){e.result=t.message(B)}},_n={default(){return{type:"batch",result:ee.default()}},1(t,e){e.result=t.message(ee)}},qn={default(){return{type:"describe",result:te.default()}},1(t,e){e.result=t.message(te)}},gn={default(){return{type:"get_autocommit",isAutocommit:!1}},1(t,e){e.isAutocommit=t.bool()}},Rn={default(){return{baton:void 0,baseUrl:void 0}},1(t,e){e.baton=t.string()},2(t,e){e.baseUrl=t.string()}};class Sn extends ut{#e;#t;#s;#n;#i;#r;constructor(e,s){super(),this.#e=e,this.#t=s,this.#s=void 0,this.#n=new ln(16*1024),this.#i=void 0,this.#r=!1}async open(e){if(e.body===null)throw new u("No response body for cursor request");this.#s=e.body.getReader();const s=await this.#o(pn,Rn);if(s===void 0)throw new u("Empty response to cursor request");return s}next(){return this.#o(yt,qt)}close(){this._setClosed(new d("Cursor was manually closed"))}_setClosed(e){this.#i===void 0&&(this.#i=e,this.#e._cursorClosed(this),this.#s!==void 0&&this.#s.cancel())}get closed(){return this.#i!==void 0}async#o(e,s){for(;;){if(this.#r)return;if(this.#i!==void 0)throw new _("Cursor is closed",this.#i);if(this.#t==="json"){const i=this.#c();if(i!==void 0){const c=new TextDecoder().decode(i),o=JSON.parse(c);return _e(o,e)}}else if(this.#t==="protobuf"){const i=this.#a();if(i!==void 0)return se(i,s)}else throw f(this.#t,"Impossible encoding");if(this.#s===void 0)throw new C("Attempted to read from HTTP cursor before it was opened");const{value:n,done:r}=await this.#s.read();if(r&&this.#n.length===0)this.#r=!0;else{if(r)throw new u("Unexpected end of cursor stream");this.#n.push(n)}}}#c(){const e=this.#n.data(),s=10,n=e.indexOf(s);if(n<0)return;const r=e.slice(0,n);return this.#n.shift(n+1),r}#a(){const e=this.#n.data();let s=0,n=0;for(;;){if(n>=e.byteLength)return;const i=e[n];if(s|=(i&127)<<7*n,n+=1,!(i&128))break}if(e.byteLength<n+s)return;const r=e.slice(n,n+s);return this.#n.shift(n+s),r}}function Cn(t,e){e.baton!==void 0&&t.string("baton",e.baton),t.arrayObjects("requests",e.requests,In)}function In(t,e){if(t.stringRaw("type",e.type),e.type!=="close"){if(e.type==="execute")t.object("stmt",e.stmt,Se);else if(e.type==="batch")t.object("batch",e.batch,X);else if(e.type==="sequence")e.sql!==void 0&&t.string("sql",e.sql),e.sqlId!==void 0&&t.number("sql_id",e.sqlId);else if(e.type==="describe")e.sql!==void 0&&t.string("sql",e.sql),e.sqlId!==void 0&&t.number("sql_id",e.sqlId);else if(e.type==="store_sql")t.number("sql_id",e.sqlId),t.string("sql",e.sql);else if(e.type==="close_sql")t.number("sql_id",e.sqlId);else if(e.type!=="get_autocommit")throw f(e,"Impossible type of StreamRequest")}}function xn(t,e){e.baton!==void 0&&t.string("baton",e.baton),t.object("batch",e.batch,X)}function An(t,e){e.baton!==void 0&&t.string(1,e.baton);for(const s of e.requests)t.message(2,s,En)}function En(t,e){if(e.type==="close")t.message(1,e,kn);else if(e.type==="execute")t.message(2,e,Tn);else if(e.type==="batch")t.message(3,e,Un);else if(e.type==="sequence")t.message(4,e,On);else if(e.type==="describe")t.message(5,e,Pn);else if(e.type==="store_sql")t.message(6,e,Ln);else if(e.type==="close_sql")t.message(7,e,$n);else if(e.type==="get_autocommit")t.message(8,e,vn);else throw f(e,"Impossible type of StreamRequest")}function kn(t,e){}function Tn(t,e){t.message(1,e.stmt,Ce)}function Un(t,e){t.message(1,e.batch,ne)}function On(t,e){e.sql!==void 0&&t.string(1,e.sql),e.sqlId!==void 0&&t.int32(2,e.sqlId)}function Pn(t,e){e.sql!==void 0&&t.string(1,e.sql),e.sqlId!==void 0&&t.int32(2,e.sqlId)}function Ln(t,e){t.int32(1,e.sqlId),t.string(2,e.sql)}function $n(t,e){t.int32(1,e.sqlId)}function vn(t,e){}function Bn(t,e){e.baton!==void 0&&t.string(1,e.baton),t.message(2,e.batch,ne)}class Nn extends at{#e;#t;#s;#n;#i;#r;#o;#c;#a;#u;#h;#p;constructor(e,s,n,r){super(e.intMode),this.#e=e,this.#t=s.toString(),this.#s=n,this.#n=r,this.#i=void 0,this.#r=new K,this.#o=!1,this.#a=!1,this.#u=!1,this.#h=void 0,this.#p=new F}client(){return this.#e}_sqlOwner(){return this}storeSql(e){const s=this.#p.alloc();return this.#d({type:"store_sql",sqlId:s,sql:e}).then(()=>{},n=>this._setClosed(n)),new ge(this,s)}_closeSql(e){this.#h===void 0&&this.#d({type:"close_sql",sqlId:e}).then(()=>this.#p.free(e),s=>this._setClosed(s))}_execute(e){return this.#d({type:"execute",stmt:e}).then(s=>s.result)}_batch(e){return this.#d({type:"batch",batch:e}).then(s=>s.result)}_describe(e){return this.#d({type:"describe",sql:e.sql,sqlId:e.sqlId}).then(s=>s.result)}_sequence(e){return this.#d({type:"sequence",sql:e.sql,sqlId:e.sqlId}).then(s=>{})}getAutocommit(){return this.#e._ensureVersion(3,"getAutocommit()"),this.#d({type:"get_autocommit"}).then(e=>e.isAutocommit)}#d(e){return new Promise((s,n)=>{this.#y({type:"pipeline",request:e,responseCallback:s,errorCallback:n})})}_openCursor(e){return new Promise((s,n)=>{this.#y({type:"cursor",batch:e,cursorCallback:s,errorCallback:n})})}_cursorClosed(e){if(e!==this.#c)throw new C("Cursor was closed, but it was not associated with the stream");this.#c=void 0,O(()=>this.#f())}close(){this._setClosed(new d("Stream was manually closed"))}closeGracefully(){this.#a=!0,O(()=>this.#f())}get closed(){return this.#h!==void 0||this.#a}_setClosed(e){if(this.#h===void 0){for(this.#h=e,this.#c!==void 0&&this.#c._setClosed(e),this.#e._streamClosed(this);;){const s=this.#r.shift();if(s!==void 0)s.errorCallback(e);else break}(this.#i!==void 0||this.#o)&&!this.#u&&(this.#r.push({type:"pipeline",request:{type:"close"},responseCallback:()=>{},errorCallback:()=>{}}),this.#u=!0,O(()=>this.#f()))}}#y(e){if(this.#h!==void 0)throw new _("Stream is closed",this.#h);if(this.#a)throw new _("Stream is closing",void 0);this.#r.push(e),O(()=>this.#f())}#f(){if(this.#o||this.#c!==void 0)return;if(this.#a&&this.#r.length===0){this._setClosed(new d("Stream was gracefully closed"));return}const e=this.#e._endpoint;if(e===void 0){this.#e._endpointPromise.then(()=>this.#f(),n=>this._setClosed(n));return}const s=this.#r.shift();if(s!==void 0)if(s.type==="pipeline"){const n=[s];for(;;){const r=this.#r.first();if(r!==void 0&&r.type==="pipeline")n.push(r),this.#r.shift();else if(r===void 0&&this.#a&&!this.#u){n.push({type:"pipeline",request:{type:"close"},responseCallback:()=>{},errorCallback:()=>{}}),this.#u=!0;break}else break}this.#l(e,n)}else if(s.type==="cursor")this.#w(e,s);else throw f(s,"Impossible type of QueueEntry")}#l(e,s){this.#m(()=>this.#_(s,e),n=>Dn(n,e.encoding),n=>n.baton,n=>n.baseUrl,n=>Mn(s,n),n=>s.forEach(r=>r.errorCallback(n)))}#w(e,s){const n=new Sn(this,e.encoding);this.#c=n,this.#m(()=>this.#q(s,e),r=>n.open(r),r=>r.baton,r=>r.baseUrl,r=>s.cursorCallback(n),r=>s.errorCallback(r))}#m(e,s,n,r,i,c){let o;try{const a=e(),l=this.#n;o=l(a)}catch(a){o=Promise.reject(a)}this.#o=!0,o.then(a=>a.ok?s(a):Vn(a).then(l=>{throw l})).then(a=>{this.#i=n(a),this.#t=r(a)??this.#t,i(a)}).catch(a=>{this._setClosed(a),c(a)}).finally(()=>{this.#o=!1,this.#f()})}#_(e,s){return this.#b(new URL(s.pipelinePath,this.#t),{baton:this.#i,requests:e.map(n=>n.request)},s.encoding,Cn,An)}#q(e,s){if(s.cursorPath===void 0)throw new L(`Cursors are supported only on protocol version 3 and higher, but the HTTP server only supports version ${s.version}.`);return this.#b(new URL(s.cursorPath,this.#t),{baton:this.#i,batch:e.batch},s.encoding,xn,Bn)}#b(e,s,n,r,i){let c,o;if(n==="json")c=et(s,r),o="application/json";else if(n==="protobuf")c=tt(s,i),o="application/x-protobuf";else throw f(n,"Impossible encoding");const a=new un;return a.set("content-type",o),this.#s!==void 0&&a.set("authorization",`Bearer ${this.#s}`),new Rt(e.toString(),{method:"POST",headers:a,body:c})}}function Mn(t,e){if(e.results.length!==t.length)throw new u("Server returned unexpected number of pipeline results");for(let s=0;s<t.length;++s){const n=e.results[s],r=t[s];if(n.type==="ok"){if(n.response.type!==r.request.type)throw new u("Received unexpected type of response");r.responseCallback(n.response)}else if(n.type==="error")r.errorCallback($(n.error));else throw n.type==="none"?new u("Received unrecognized type of StreamResult"):f(n,"Received impossible type of StreamResult")}}async function Dn(t,e){if(e==="json"){const s=await t.json();return _e(s,hn)}else if(e==="protobuf"){const s=await t.arrayBuffer();return se(new Uint8Array(s),yn)}else throw f(e,"Impossible encoding")}async function Vn(t){const e=t.headers.get("content-type")??"text/plain";if(e==="application/json"){const n=await t.json();if("message"in n)return $(n)}let s=`Server returned HTTP status ${t.status}`;if(e==="text/plain"){const n=(await t.text()).trim();n!==""&&(s+=`: ${n}`)}return t.status===404&&(s+=". It seems that the libsql server is outdated, please try updating the database."),new Xe(s,t.status)}const Fn=[{versionPath:"v3-protobuf",pipelinePath:"v3-protobuf/pipeline",cursorPath:"v3-protobuf/cursor",version:3,encoding:"protobuf"}],ye={versionPath:"v2",pipelinePath:"v2/pipeline",cursorPath:void 0,version:2,encoding:"json"};let jn=class extends Ze{#e;#t;#s;#n;#i;_endpointPromise;_endpoint;constructor(e,s,n,r=2){super(),this.#e=e,this.#t=s,this.#s=n??an,this.#n=void 0,this.#i=new Set,r==3?(this._endpointPromise=Hn(this.#s,this.#e),this._endpointPromise.then(i=>this._endpoint=i,i=>this.#r(i))):(this._endpointPromise=Promise.resolve(ye),this._endpointPromise.then(i=>this._endpoint=i,i=>this.#r(i)))}async getVersion(){return this._endpoint!==void 0?this._endpoint.version:(await this._endpointPromise).version}_ensureVersion(e,s){if(!(e<=ye.version)){if(this._endpoint===void 0)throw new L(`${s} is supported only on protocol version ${e} and higher, but the version supported by the HTTP server is not yet known. Use Client.getVersion() to wait until the version is available.`);if(this._endpoint.version<e)throw new L(`${s} is supported only on protocol version ${e} and higher, but the HTTP server only supports version ${this._endpoint.version}.`)}}openStream(){if(this.#n!==void 0)throw new _("Client is closed",this.#n);const e=new Nn(this,this.#e,this.#t,this.#s);return this.#i.add(e),e}_streamClosed(e){this.#i.delete(e)}close(){this.#r(new d("Client was manually closed"))}get closed(){return this.#n!==void 0}#r(e){if(this.#n===void 0){this.#n=e;for(const s of Array.from(this.#i))s._setClosed(new _("Client was closed",e))}}};async function Hn(t,e){const s=t;for(const n of Fn){const r=new URL(n.versionPath,e),i=new Rt(r.toString(),{method:"GET"}),c=await s(i);if(await c.arrayBuffer(),c.ok)return n}return ye}function St(t,e,s=2){if(typeof U>"u")throw new Ke("WebSockets are not supported in this environment");var n=void 0;s==3?n=Array.from(gt.keys()):n=Array.from(on.keys());const r=new U(t,n);return new cn(r,e)}function Wn(t,e,s,n=2){return new jn(t instanceof URL?t:new URL(t),e,s,n)}class Ct{#e;#t;#s;constructor(e,s){this.#e=e,this.#t=s,this.#s=void 0}execute(e){return this.batch([e]).then(s=>s[0])}async batch(e){const s=this._getStream();if(s.closed)throw new h("Cannot execute statements because the transaction is closed","TRANSACTION_CLOSED");try{const n=e.map(J);let r;if(this.#s===void 0){this._getSqlCache().apply(n);const c=s.batch(this.#t>=3),o=c.step(),a=o.run(ae(this.#e));let l=o;r=n.map(y=>{const R=c.step().condition(b.ok(l));this.#t>=3&&R.condition(b.not(b.isAutocommit(c)));const x=R.query(y);return x.catch(()=>{}),l=R,x}),this.#s=c.execute().then(()=>a).then(()=>{});try{await this.#s}catch(y){throw this.close(),y}}else{this.#t<3&&await this.#s,this._getSqlCache().apply(n);const c=s.batch(this.#t>=3);let o;r=n.map(a=>{const l=c.step();o!==void 0&&l.condition(b.ok(o)),this.#t>=3&&l.condition(b.not(b.isAutocommit(c)));const y=l.query(a);return y.catch(()=>{}),o=l,y}),await c.execute()}const i=[];for(const c of r){const o=await c;if(o===void 0)throw new h("Statement in a transaction was not executed, probably because the transaction has been rolled back","TRANSACTION_CLOSED");i.push(re(o))}return i}catch(n){throw p(n)}}async executeMultiple(e){const s=this._getStream();if(s.closed)throw new h("Cannot execute statements because the transaction is closed","TRANSACTION_CLOSED");try{if(this.#s===void 0){this.#s=s.run(ae(this.#e)).then(()=>{});try{await this.#s}catch(n){throw this.close(),n}}else await this.#s;await s.sequence(e)}catch(n){throw p(n)}}async rollback(){try{const e=this._getStream();if(e.closed||this.#s===void 0)return;const s=e.run("ROLLBACK").catch(n=>{throw p(n)});e.closeGracefully(),await s}catch(e){throw p(e)}finally{this.close()}}async commit(){try{const e=this._getStream();if(e.closed)throw new h("Cannot commit the transaction because it is already closed","TRANSACTION_CLOSED");if(this.#s!==void 0)await this.#s;else return;const s=e.run("COMMIT").catch(n=>{throw p(n)});e.closeGracefully(),await s}catch(e){throw p(e)}finally{this.close()}}}async function It(t,e,s,n){const r=s.step(),i=r.run(ae(t));let c=r;const o=n.map(x=>{const T=s.step().condition(b.ok(c));e>=3&&T.condition(b.not(b.isAutocommit(s)));const Et=T.query(x);return c=T,Et}),a=s.step().condition(b.ok(c));e>=3&&a.condition(b.not(b.isAutocommit(s)));const l=a.run("COMMIT");s.step().condition(b.not(b.ok(a))).run("ROLLBACK").catch(x=>{}),await s.execute();const R=[];await i;for(const x of o){const T=await x;if(T===void 0)throw new h("Statement in a batch was not executed, probably because the transaction has been rolled back","TRANSACTION_CLOSED");R.push(re(T))}return await l,R}function J(t){if(typeof t=="string")return new fe(t);const e=new fe(t.sql);if(Array.isArray(t.args))e.bindIndexes(t.args);else for(const[s,n]of Object.entries(t.args))e.bindName(s,n);return e}function re(t){const e=t.columnNames.map(c=>c??""),s=t.columnDecltypes.map(c=>c??""),n=t.rows,r=t.affectedRowCount,i=t.lastInsertRowid!==void 0?t.lastInsertRowid:void 0;return new Xt(e,s,n,r,i)}function p(t){if(t instanceof d){const e=xt(t);return new h(t.message,e,void 0,t)}return t}function xt(t){return t instanceof Ye&&t.code!==void 0?t.code:t instanceof u?"HRANA_PROTO_ERROR":t instanceof _?t.cause instanceof d?xt(t.cause):"HRANA_CLOSED_ERROR":t instanceof ue?"HRANA_WEBSOCKET_ERROR":t instanceof Xe?"SERVER_ERROR":t instanceof L?"PROTOCOL_VERSION_ERROR":t instanceof C?"INTERNAL_ERROR":"UNKNOWN"}class Ae{#e;#t;capacity;constructor(e,s){this.#e=e,this.#t=new zn,this.capacity=s}apply(e){if(this.capacity<=0)return;const s=new Set;for(const n of e){if(typeof n.sql!="string")continue;const r=n.sql;let i=this.#t.get(r);if(i===void 0){for(;this.#t.size+1>this.capacity;){const[c,o]=this.#t.peekLru();if(s.has(o))break;o.close(),this.#t.delete(c)}this.#t.size+1<=this.capacity&&(i=this.#e.storeSql(r),this.#t.set(r,i))}i!==void 0&&(n.sql=i,s.add(i))}}}class zn{#e;constructor(){this.#e=new Map}get(e){const s=this.#e.get(e);return s!==void 0&&(this.#e.delete(e),this.#e.set(e,s)),s}set(e,s){this.#e.set(e,s)}peekLru(){for(const e of this.#e.entries())return e}delete(e){this.#e.delete(e)}get size(){return this.#e.size}}function Jn(t){if(t.scheme!=="wss"&&t.scheme!=="ws")throw new h(`The WebSocket client supports only "libsql:", "wss:" and "ws:" URLs, got ${JSON.stringify(t.scheme+":")}. For more information, please read ${W}`,"URL_SCHEME_NOT_SUPPORTED");if(t.scheme==="ws"&&t.tls)throw new h('A "ws:" URL cannot opt into TLS by using ?tls=1',"URL_INVALID");if(t.scheme==="wss"&&!t.tls)throw new h('A "wss:" URL cannot opt out of TLS by using ?tls=0',"URL_INVALID");const e=ie(t.scheme,t.authority,t.path);let s;try{s=St(e,t.authToken)}catch(n){if(n instanceof Ke){const r=t.scheme==="wss"?"https":"http",i=ie(r,t.authority,t.path);throw new h(`This environment does not support WebSockets, please switch to the HTTP client by using a "${r}:" URL (${JSON.stringify(i)}). For more information, please read ${W}`,"WEBSOCKETS_NOT_SUPPORTED")}throw p(n)}return new Zn(s,e,t.authToken,t.intMode)}const Gn=60*1e3,Qn=100;class Zn{#e;#t;#s;#n;#i;closed;protocol;constructor(e,s,n,r){this.#e=s,this.#t=n,this.#s=r,this.#n=this.#o(e),this.#i=void 0,this.closed=!1,this.protocol="ws"}async execute(e){const s=await this.#r();try{const n=J(e);s.conn.sqlCache.apply([n]);const r=s.stream.query(n);return s.stream.closeGracefully(),re(await r)}catch(n){throw p(n)}finally{this._closeStream(s)}}async batch(e,s="deferred"){const n=await this.#r();try{const r=e.map(J),i=await n.conn.client.getVersion();n.conn.sqlCache.apply(r);const c=n.stream.batch(i>=3);return await It(s,i,c,r)}catch(r){throw p(r)}finally{this._closeStream(n)}}async transaction(e="write"){const s=await this.#r();try{const n=await s.conn.client.getVersion();return new Yn(this,s,e,n)}catch(n){throw this._closeStream(s),p(n)}}async executeMultiple(e){const s=await this.#r();try{const n=s.stream.sequence(e);s.stream.closeGracefully(),await n}catch(n){throw p(n)}finally{this._closeStream(s)}}sync(){return Promise.resolve()}async#r(){if(this.closed)throw new h("The client is closed","CLIENT_CLOSED");if(new Date().valueOf()-this.#n.openTime.valueOf()>Gn&&this.#i===void 0){const r=this.#o();this.#i=r,r.client.getVersion().then(i=>{this.#n!==r&&this.#n.streamStates.size===0&&this.#n.client.close(),this.#n=r,this.#i=void 0},i=>{this.#i=void 0})}if(this.#n.client.closed)try{this.#i!==void 0?this.#n=this.#i:this.#n=this.#o()}catch(r){throw p(r)}const n=this.#n;try{n.useSqlCache===void 0&&(n.useSqlCache=await n.client.getVersion()>=2,n.useSqlCache&&(n.sqlCache.capacity=Qn));const r=n.client.openStream();r.intMode=this.#s;const i={conn:n,stream:r};return n.streamStates.add(i),i}catch(r){throw p(r)}}#o(e){try{return e??=St(this.#e,this.#t),{client:e,useSqlCache:void 0,sqlCache:new Ae(e,0),openTime:new Date,streamStates:new Set}}catch(s){throw p(s)}}_closeStream(e){e.stream.close();const s=e.conn;s.streamStates.delete(e),s.streamStates.size===0&&s!==this.#n&&s.client.close()}close(){this.#n.client.close(),this.closed=!0}}class Yn extends Ct{#e;#t;constructor(e,s,n,r){super(n,r),this.#e=e,this.#t=s}_getStream(){return this.#t.stream}_getSqlCache(){return this.#t.conn.sqlCache}close(){this.#e._closeStream(this.#t)}get closed(){return this.#t.stream.closed}}function Kn(t){if(t.scheme!=="https"&&t.scheme!=="http")throw new h(`The HTTP client supports only "libsql:", "https:" and "http:" URLs, got ${JSON.stringify(t.scheme+":")}. For more information, please read ${W}`,"URL_SCHEME_NOT_SUPPORTED");if(t.scheme==="http"&&t.tls)throw new h('A "http:" URL cannot opt into TLS by using ?tls=1',"URL_INVALID");if(t.scheme==="https"&&!t.tls)throw new h('A "https:" URL cannot opt out of TLS by using ?tls=0',"URL_INVALID");const e=ie(t.scheme,t.authority,t.path);return new Xn(e,t.authToken,t.intMode,t.fetch)}const At=30;class Xn{#e;protocol;constructor(e,s,n,r){this.#e=Wn(e,s,r),this.#e.intMode=n,this.protocol="http"}async execute(e){try{const s=J(e);let n;const r=this.#e.openStream();try{n=r.query(s)}finally{r.closeGracefully()}return re(await n)}catch(s){throw p(s)}}async batch(e,s="deferred"){try{const n=e.map(J),r=await this.#e.getVersion();let i;const c=this.#e.openStream();try{new Ae(c,At).apply(n);const a=c.batch(!1);i=It(s,r,a,n)}finally{c.closeGracefully()}return await i}catch(n){throw p(n)}}async transaction(e="write"){try{const s=await this.#e.getVersion();return new er(this.#e.openStream(),e,s)}catch(s){throw p(s)}}async executeMultiple(e){try{let s;const n=this.#e.openStream();try{s=n.sequence(e)}finally{n.closeGracefully()}await s}catch(s){throw p(s)}}sync(){throw new h("sync not supported in http mode","SYNC_NOT_SUPPORTED")}close(){this.#e.close()}get closed(){return this.#e.closed}}class er extends Ct{#e;#t;constructor(e,s,n){super(s,n),this.#e=e,this.#t=new Ae(e,At)}_getStream(){return this.#e}_getSqlCache(){return this.#t}close(){this.#e.close()}get closed(){return this.#e.closed}}function tr(t){return sr(ss(t,!0))}function sr(t){if(t.scheme==="ws"||t.scheme==="wss")return Jn(t);if(t.scheme==="http"||t.scheme==="https")return Kn(t);throw new h(`The client that uses Web standard APIs supports only "libsql:", "wss:", "ws:", "https:" and "http:" URLs, got ${JSON.stringify(t.scheme+":")}. For more information, please read ${W}`,"URL_SCHEME_NOT_SUPPORTED")}const nr=tr({url:"libsql://sign-gen-logno-dev.turso.io",authToken:"eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9.eyJpYXQiOiIyMDI0LTAxLTA3VDAwOjU5OjM5LjUyMzMwMzIxNFoiLCJpZCI6IjhiYTQ3YWNjLWFjZjItMTFlZS04NDljLWRlNTQ3NWY0NjQ5ZiJ9.DiCFOAfLGWPsqScN3moZrzaZzcekxlA_kXvq_hTXb7_R8JR475PQxgIjxGbdflepkDH4oYOduqGu9Sj3ccFyBQ"});async function rr(){return(await nr.execute("select * from test")).rows[0][1]}const ir=Ut("<main><h1>About</h1><pre>");function dr(){const[t]=kt({},rr);return(()=>{const e=ir(),s=e.firstChild,n=s.nextSibling;return Ee(e,Tt(Ot,{children:"About"}),s),Ee(n,()=>JSON.stringify(t(),null,2)),e})()}export{dr as default};
